{"ast":null,"code":"var _jsxFileName = \"D:\\\\Redux\\\\Redux_07_Integrate_Redux_in_React_app_react-redux\\\\to-do-app\\\\frontend\\\\src\\\\App.js\";\nimport React from 'react';\nimport Tasks from './components/Tasks';\nimport store from \"./store/configureStore\";\nimport StoreContext from './contexts/storeContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst App = () => {\n  return /*#__PURE__*/_jsxDEV(StoreContext.Provider, {\n    value: store,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [\" \", /*#__PURE__*/_jsxDEV(Tasks, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 13,\n        columnNumber: 13\n      }, this), \" \"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 11,\n    columnNumber: 5\n  }, this);\n};\n_c = App;\nexport default App;\n\n// We pass the store as a a props to this task component.   <Tasks store={store} /> \n\n// Imagine we have multiple components and this Task component is deep in the component tree.\n// Then we have to pass this prop in all over the components, and that will be very messy.\n// So to solve this, we can use very useful reat feature, which is \"context\".\n// So with context, we can use this tool in every component which is available in app component.\n\n// What ever component is available in between this provider,\n// that Component and its child components can access this value, which is \"store\".\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","Tasks","store","StoreContext","jsxDEV","_jsxDEV","App","Provider","value","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Redux/Redux_07_Integrate_Redux_in_React_app_react-redux/to-do-app/frontend/src/App.js"],"sourcesContent":["import React from 'react'\nimport Tasks from './components/Tasks'\n\nimport store from \"./store/configureStore\"\n\nimport StoreContext from './contexts/storeContext'\n\nconst App = () => {\n  return (\n\n    <StoreContext.Provider value={store}>\n\n      <div> <Tasks /> </div>\n\n    </StoreContext.Provider>   \n\n  )\n}\n\nexport default App\n\n\n// We pass the store as a a props to this task component.   <Tasks store={store} /> \n\n// Imagine we have multiple components and this Task component is deep in the component tree.\n// Then we have to pass this prop in all over the components, and that will be very messy.\n// So to solve this, we can use very useful reat feature, which is \"context\".\n// So with context, we can use this tool in every component which is available in app component.\n\n// What ever component is available in between this provider,\n// that Component and its child components can access this value, which is \"store\".\n\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,KAAK,MAAM,oBAAoB;AAEtC,OAAOC,KAAK,MAAM,wBAAwB;AAE1C,OAAOC,YAAY,MAAM,yBAAyB;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAElD,MAAMC,GAAG,GAAGA,CAAA,KAAM;EAChB,oBAEED,OAAA,CAACF,YAAY,CAACI,QAAQ;IAACC,KAAK,EAAEN,KAAM;IAAAO,QAAA,eAElCJ,OAAA;MAAAI,QAAA,GAAK,GAAC,eAAAJ,OAAA,CAACJ,KAAK;QAAAS,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,KAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAED,CAAC;AAG5B,CAAC;AAAAC,EAAA,GAVKR,GAAG;AAYT,eAAeA,GAAG;;AAGlB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA,IAAAQ,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}